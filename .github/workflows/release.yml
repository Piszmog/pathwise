name: Release
on:
  workflow_dispatch:
    inputs:
      increment:
        description: 'Version increment type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch
permissions:
  contents: write
jobs:
  calculate-version:
    name: Calculate Version
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Get latest release
        id: latest_release
        run: |
          LATEST_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
          if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
            LATEST_TAG="v0.0.0"
          fi
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Calculate new version
        id: version
        run: |
          LATEST_TAG="${{ steps.latest_release.outputs.latest_tag }}"
          INCREMENT="${{ github.event.inputs.increment }}"
          # Remove 'v' prefix if present
          VERSION=${LATEST_TAG#v}
          # Split version into parts
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          # Calculate new version based on increment type
          case $INCREMENT in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Calculated new version: $NEW_VERSION (from $LATEST_TAG using $INCREMENT increment)"
      - name: Announce new version
        run: |
          echo "::notice title=New Release Version::Releasing ${{ steps.version.outputs.new_version }} (increment: ${{ github.event.inputs.increment }})"
  tag:
    name: Tag
    runs-on: ubuntu-latest
    needs: [calculate-version]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Create Tag
        uses: piszmog/create-tag@v1
        with:
          version: ${{ needs.calculate-version.outputs.new_version }}
          message: ${{ needs.calculate-version.outputs.new_version }}
          token: ${{ secrets.GITHUB_TOKEN }}
  release:
    name: Release UI
    runs-on: ubuntu-latest
    needs: [tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false
      - name: Run UI GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: '~> v2'
          args: release --clean --config cmd/ui/.goreleaser.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload UI Linux artifact
        uses: actions/upload-artifact@v4
        with:
          name: pathwise-ui_Linux_x86_64.tar.gz
          path: goreleaser-dist/pathwise-ui_Linux_x86_64.tar.gz
          retention-days: 1
  release-mcp:
    name: Release MCP
    runs-on: ubuntu-latest
    needs: [tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false
      - name: Run MCP GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: '~> v2'
          args: release --clean --config cmd/mcp/.goreleaser.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload MCP Linux artifact
        uses: actions/upload-artifact@v4
        with:
          name: pathwise-mcp_Linux_x86_64.tar.gz
          path: goreleaser-dist/pathwise-mcp_Linux_x86_64.tar.gz
          retention-days: 1
  release-jobs:
    name: Release Jobs
    runs-on: ubuntu-latest
    needs: [tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false
      - name: Run Jobs GoReleaser
        run: |
          docker run \
            --rm \
            -v $PWD:/go/src/github.com/user/repo \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -w /go/src/github.com/user/repo \
            -e GITHUB_TOKEN \
            ghcr.io/goreleaser/goreleaser-cross:latest \
            release --clean --config cmd/jobs/.goreleaser.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload Jobs Linux artifact
        uses: actions/upload-artifact@v4
        with:
          name: pathwise-jobs_Linux_x86_64.tar.gz
          path: goreleaser-dist/pathwise-jobs_Linux_x86_64.tar.gz
          retention-days: 1
  migrate-database:
    name: Run Database Migration
    runs-on: ubuntu-latest
    needs: [release, release-mcp, release-jobs]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false
      - name: Run database migration
        run: |
          chmod +x ./migrate.sh
          ./migrate.sh -p ${{ secrets.DB_PROTOCOL }} -u ${{ secrets.DB_URL }} -t ${{ secrets.DB_TOKEN }} -d up
  publish:
    name: Publish UI Docker
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    needs: [calculate-version, tag]
    steps:
      - uses: actions/checkout@v5
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ghcr.io/piszmog/pathwise-ui
          tags: |
            type=raw,value=${{ needs.calculate-version.outputs.new_version }}
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: cmd/ui/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ needs.calculate-version.outputs.new_version }}
  publish-mcp:
    name: Publish MCP Docker
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    needs: [calculate-version, tag]
    steps:
      - uses: actions/checkout@v5
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ghcr.io/piszmog/pathwise-mcp
          tags: |
            type=raw,value=${{ needs.calculate-version.outputs.new_version }}
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: cmd/mcp/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ needs.calculate-version.outputs.new_version }}
  publish-jobs:
    name: Publish Jobs Docker
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    needs: [calculate-version, tag]
    steps:
      - uses: actions/checkout@v5
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ghcr.io/piszmog/pathwise-jobs
          tags: |
            type=raw,value=${{ needs.calculate-version.outputs.new_version }}
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: cmd/jobs/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ needs.calculate-version.outputs.new_version }}
  deploy-vm-ui:
    name: Deploy UI to VM
    runs-on: ubuntu-latest
    needs: [release, migrate-database]
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: pathwise-ui_Linux_x86_64.tar.gz
          path: ./artifacts

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Create systemd service file
        run: |
          cat > pathwise.service << 'EOF'
          [Unit]
          Description=Pathwise Job Application Tracker
          After=network.target

          [Service]
          Type=simple
          User=ubuntu
          WorkingDirectory=/home/ubuntu/apps/pathwise
          ExecStart=/home/ubuntu/apps/pathwise/pathwise-ui
          Restart=always
          RestartSec=5
          Environment=DB_TOKEN=${{ secrets.DB_TOKEN }}
          Environment=DB_URL=${{ secrets.DB_URL }}
          Environment=LOG_OUTPUT=/var/log/pathwise/pathwise.log
          Environment=PORT=8080

          [Install]
          WantedBy=multi-user.target
          EOF

      - name: Deploy to VM
        run: |
          # Copy artifact and service file to VM
          scp ./artifacts/pathwise-ui_Linux_x86_64.tar.gz ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/tmp/
          scp pathwise.service ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/tmp/

          # Extract and deploy on VM
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            # Stop existing service if it exists
            if sudo systemctl is-active --quiet pathwise; then
              sudo systemctl stop pathwise
            fi

            # Create app directory if it doesn't exist
            mkdir -p /home/ubuntu/apps/pathwise

            # Extract new version
            cd /tmp
            tar -xzf pathwise-ui_Linux_x86_64.tar.gz

            # Move binary to app directory
            mv pathwise-ui /home/ubuntu/apps/pathwise/
            chmod +x /home/ubuntu/apps/pathwise/pathwise-ui

            # Create log directory
            sudo mkdir -p /var/log/pathwise
            sudo chown ubuntu:ubuntu /var/log/pathwise

            # Install systemd service file
            sudo mv /tmp/pathwise.service /etc/systemd/system/
          EOF

          # Start service and health check
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            # Reload systemd and start service
            sudo systemctl daemon-reload
            sudo systemctl start pathwise
            sudo systemctl enable pathwise

            # Check status
            sudo systemctl status pathwise
            # Wait for service to start
            sleep 10
            # Health check
            if curl -f http://localhost:8080/health; then
              echo "✅ Health check passed - app is running"
            else
              echo "❌ Health check failed - app is not responding"
              exit 1
            fi
          EOF
      - name: Cleanup
        run: |
          rm -f ~/.ssh/id_rsa
  deploy-vm-mcp:
    name: Deploy MCP to VM
    runs-on: ubuntu-latest
    needs: [release-mcp, migrate-database]
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: pathwise-mcp_Linux_x86_64.tar.gz
          path: ./artifacts

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Create systemd service file
        run: |
          cat > pathwise-mcp.service << 'EOF'
          [Unit]
          Description=Pathwise MCP Server
          After=network.target

          [Service]
          Type=simple
          User=ubuntu
          WorkingDirectory=/home/ubuntu/apps/pathwise-mcp
          ExecStart=/home/ubuntu/apps/pathwise-mcp/pathwise-mcp
          Restart=always
          RestartSec=5
          Environment=DB_TOKEN_READONLY=${{ secrets.DB_TOKEN_READONLY }}
          Environment=DB_PRIMARY_URL=${{ secrets.DB_URL }}
          Environment=ENC_KEY=${{ secrets.ENC_KEY }}
          Environment=LOG_OUTPUT=/var/log/pathwise/pathwise-mcp.log
          Environment=PORT=8081

          [Install]
          WantedBy=multi-user.target
          EOF

      - name: Deploy to VM
        run: |
          # Copy artifact and service file to VM
          scp ./artifacts/pathwise-mcp_Linux_x86_64.tar.gz ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/tmp/
          scp pathwise-mcp.service ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/tmp/

          # Extract and deploy on VM
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            # Stop existing service if it exists
            if sudo systemctl is-active --quiet pathwise-mcp; then
              sudo systemctl stop pathwise-mcp
            fi

            # Create app directory if it doesn't exist
            mkdir -p /home/ubuntu/apps/pathwise-mcp

            # Extract new version
            cd /tmp
            tar -xzf pathwise-mcp_Linux_x86_64.tar.gz

            # Move binary to app directory
            mv pathwise-mcp /home/ubuntu/apps/pathwise-mcp/
            chmod +x /home/ubuntu/apps/pathwise-mcp/pathwise-mcp

            # Create log directory if it doesn't exist
            sudo mkdir -p /var/log/pathwise
            sudo chown ubuntu:ubuntu /var/log/pathwise

            # Install systemd service file
            sudo mv /tmp/pathwise-mcp.service /etc/systemd/system/
          EOF

          # Start service and check status
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            # Reload systemd and start service
            sudo systemctl daemon-reload
            sudo systemctl start pathwise-mcp
            sudo systemctl enable pathwise-mcp

           # Check status
           sudo systemctl status pathwise-mcp
         EOF
      - name: Cleanup
        run: |
          rm -f ~/.ssh/id_rsa
  deploy-vm-jobs:
    name: Deploy Jobs to VM
    runs-on: ubuntu-latest
    needs: [release-jobs, migrate-database]
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: pathwise-jobs_Linux_x86_64.tar.gz
          path: ./artifacts

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Create systemd service file
        run: |
          cat > pathwise-jobs.service << 'EOF'
          [Unit]
          Description=Pathwise Jobs Processor
          After=network.target

          [Service]
          Type=simple
          User=ubuntu
          WorkingDirectory=/home/ubuntu/apps/pathwise-jobs
          ExecStart=/home/ubuntu/apps/pathwise-jobs/pathwise-jobs
          Restart=always
          RestartSec=5
          Environment=DB_TOKEN=${{ secrets.DB_TOKEN }}
          Environment=DB_URL=${{ secrets.DB_URL }}
          Environment=GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          Environment=LOG_OUTPUT=/var/log/pathwise/pathwise-jobs.log

          [Install]
          WantedBy=multi-user.target
          EOF

      - name: Deploy to VM
        run: |
          # Copy artifact and service file to VM
          scp ./artifacts/pathwise-jobs_Linux_x86_64.tar.gz ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/tmp/
          scp pathwise-jobs.service ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/tmp/

          # Extract and deploy on VM
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            # Stop existing service if it exists
            if sudo systemctl is-active --quiet pathwise-jobs; then
              sudo systemctl stop pathwise-jobs
            fi

            # Create app directory if it doesn't exist
            mkdir -p /home/ubuntu/apps/pathwise-jobs

            # Extract new version
            cd /tmp
            tar -xzf pathwise-jobs_Linux_x86_64.tar.gz

            # Move binary to app directory
            mv pathwise-jobs /home/ubuntu/apps/pathwise-jobs/
            chmod +x /home/ubuntu/apps/pathwise-jobs/pathwise-jobs

            # Create log directory if it doesn't exist
            sudo mkdir -p /var/log/pathwise
            sudo chown ubuntu:ubuntu /var/log/pathwise

            # Install systemd service file
            sudo mv /tmp/pathwise-jobs.service /etc/systemd/system/
          EOF

          # Start service and check status
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            # Reload systemd and start service
            sudo systemctl daemon-reload
            sudo systemctl start pathwise-jobs
            sudo systemctl enable pathwise-jobs

            # Check status
            sudo systemctl status pathwise-jobs
          EOF
      - name: Cleanup
        run: |
          rm -f ~/.ssh/id_rsa
