// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: job_application.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const archiveJobApplication = `-- name: ArchiveJobApplication :exec
UPDATE job_applications
	SET archived = 1,
		updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
`

type ArchiveJobApplicationParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) ArchiveJobApplication(ctx context.Context, arg ArchiveJobApplicationParams) error {
	_, err := q.db.ExecContext(ctx, archiveJobApplication, arg.ID, arg.UserID)
	return err
}

const archiveJobApplications = `-- name: ArchiveJobApplications :exec
UPDATE job_applications
	SET archived = 1,
		updated_at = CURRENT_TIMESTAMP
WHERE user_id = ?
AND applied_at <= ?
`

type ArchiveJobApplicationsParams struct {
	UserID    int64
	AppliedAt time.Time
}

func (q *Queries) ArchiveJobApplications(ctx context.Context, arg ArchiveJobApplicationsParams) error {
	_, err := q.db.ExecContext(ctx, archiveJobApplications, arg.UserID, arg.AppliedAt)
	return err
}

const countJobApplicationCompanies = `-- name: CountJobApplicationCompanies :one
SELECT
	COUNT(DISTINCT company)
FROM
	job_applications j
WHERE
	j.user_id = ? AND j.archived = ?
`

type CountJobApplicationCompaniesParams struct {
	UserID   int64
	Archived int64
}

func (q *Queries) CountJobApplicationCompanies(ctx context.Context, arg CountJobApplicationCompaniesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobApplicationCompanies, arg.UserID, arg.Archived)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobApplicationCompany = `-- name: CountJobApplicationCompany :one
SELECT COUNT(*) FROM job_applications WHERE company = ? AND user_id = ? AND archived = ?
`

type CountJobApplicationCompanyParams struct {
	Company  string
	UserID   int64
	Archived int64
}

func (q *Queries) CountJobApplicationCompany(ctx context.Context, arg CountJobApplicationCompanyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobApplicationCompany, arg.Company, arg.UserID, arg.Archived)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobApplicationsByUserID = `-- name: CountJobApplicationsByUserID :one
SELECT COUNT(*) FROM job_applications WHERE user_id = ? AND archived = ?
`

type CountJobApplicationsByUserIDParams struct {
	UserID   int64
	Archived int64
}

func (q *Queries) CountJobApplicationsByUserID(ctx context.Context, arg CountJobApplicationsByUserIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobApplicationsByUserID, arg.UserID, arg.Archived)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobApplicationsByUserIDAndCompany = `-- name: CountJobApplicationsByUserIDAndCompany :one
SELECT COUNT(*) FROM job_applications WHERE company LIKE ? AND user_id = ? AND archived = ?
`

type CountJobApplicationsByUserIDAndCompanyParams struct {
	Company  string
	UserID   int64
	Archived int64
}

func (q *Queries) CountJobApplicationsByUserIDAndCompany(ctx context.Context, arg CountJobApplicationsByUserIDAndCompanyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobApplicationsByUserIDAndCompany, arg.Company, arg.UserID, arg.Archived)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobApplicationsByUserIDAndCompanyAndStatus = `-- name: CountJobApplicationsByUserIDAndCompanyAndStatus :one
SELECT COUNT(*) FROM job_applications WHERE company = ? AND status = ? AND user_id = ? AND archived = ?
`

type CountJobApplicationsByUserIDAndCompanyAndStatusParams struct {
	Company  string
	Status   string
	UserID   int64
	Archived int64
}

func (q *Queries) CountJobApplicationsByUserIDAndCompanyAndStatus(ctx context.Context, arg CountJobApplicationsByUserIDAndCompanyAndStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobApplicationsByUserIDAndCompanyAndStatus,
		arg.Company,
		arg.Status,
		arg.UserID,
		arg.Archived,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobApplicationsByUserIDAndStatus = `-- name: CountJobApplicationsByUserIDAndStatus :one
SELECT COUNT(*) FROM job_applications WHERE status = ? AND user_id = ? AND archived = ?
`

type CountJobApplicationsByUserIDAndStatusParams struct {
	Status   string
	UserID   int64
	Archived int64
}

func (q *Queries) CountJobApplicationsByUserIDAndStatus(ctx context.Context, arg CountJobApplicationsByUserIDAndStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobApplicationsByUserIDAndStatus, arg.Status, arg.UserID, arg.Archived)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobApplicationsForStats = `-- name: CountJobApplicationsForStats :one
SELECT
	COUNT(*)
FROM 
	job_applications j
JOIN job_application_status_histories h 
	ON h.job_application_id = j.id
WHERE
	j.user_id = ? AND j.archived = 0
`

func (q *Queries) CountJobApplicationsForStats(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobApplicationsForStats, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllJobApplicationsByUserID = `-- name: GetAllJobApplicationsByUserID :many
SELECT
	j.applied_at, j.updated_at, j.company, j.title, j.status, j.url,
	j.salary_min, j.salary_max, j.salary_currency
FROM 
	job_applications j
WHERE
	j.user_id = ?
ORDER BY j.applied_at DESC
`

type GetAllJobApplicationsByUserIDRow struct {
	AppliedAt      time.Time
	UpdatedAt      time.Time
	Company        string
	Title          string
	Status         string
	Url            string
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
}

func (q *Queries) GetAllJobApplicationsByUserID(ctx context.Context, userID int64) ([]GetAllJobApplicationsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobApplicationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobApplicationsByUserIDRow
	for rows.Next() {
		var i GetAllJobApplicationsByUserIDRow
		if err := rows.Scan(
			&i.AppliedAt,
			&i.UpdatedAt,
			&i.Company,
			&i.Title,
			&i.Status,
			&i.Url,
			&i.SalaryMin,
			&i.SalaryMax,
			&i.SalaryCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobApplicationByID = `-- name: GetJobApplicationByID :one
SELECT
	j.applied_at, j.updated_at, j.company, j.title, j.status, j.url, j.id, j.user_id, j.archived,
	j.salary_min, j.salary_max, j.salary_currency
FROM 
	job_applications j
WHERE
	j.id = ?
`

type GetJobApplicationByIDRow struct {
	AppliedAt      time.Time
	UpdatedAt      time.Time
	Company        string
	Title          string
	Status         string
	Url            string
	ID             int64
	UserID         int64
	Archived       int64
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
}

func (q *Queries) GetJobApplicationByID(ctx context.Context, id int64) (GetJobApplicationByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getJobApplicationByID, id)
	var i GetJobApplicationByIDRow
	err := row.Scan(
		&i.AppliedAt,
		&i.UpdatedAt,
		&i.Company,
		&i.Title,
		&i.Status,
		&i.Url,
		&i.ID,
		&i.UserID,
		&i.Archived,
		&i.SalaryMin,
		&i.SalaryMax,
		&i.SalaryCurrency,
	)
	return i, err
}

const getJobApplicationByIDAndUserID = `-- name: GetJobApplicationByIDAndUserID :one
SELECT
	j.applied_at, j.updated_at, j.company, j.title, j.status, j.url, j.id, j.user_id,
	j.salary_min, j.salary_max, j.salary_currency
FROM
	job_applications j
WHERE
	j.id = ? AND j.user_id = ?
`

type GetJobApplicationByIDAndUserIDParams struct {
	ID     int64
	UserID int64
}

type GetJobApplicationByIDAndUserIDRow struct {
	AppliedAt      time.Time
	UpdatedAt      time.Time
	Company        string
	Title          string
	Status         string
	Url            string
	ID             int64
	UserID         int64
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
}

func (q *Queries) GetJobApplicationByIDAndUserID(ctx context.Context, arg GetJobApplicationByIDAndUserIDParams) (GetJobApplicationByIDAndUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getJobApplicationByIDAndUserID, arg.ID, arg.UserID)
	var i GetJobApplicationByIDAndUserIDRow
	err := row.Scan(
		&i.AppliedAt,
		&i.UpdatedAt,
		&i.Company,
		&i.Title,
		&i.Status,
		&i.Url,
		&i.ID,
		&i.UserID,
		&i.SalaryMin,
		&i.SalaryMax,
		&i.SalaryCurrency,
	)
	return i, err
}

const getJobApplicationsByUserID = `-- name: GetJobApplicationsByUserID :many
SELECT
	j.applied_at, j.updated_at, j.company, j.title, j.status, j.url, j.id,
	j.salary_min, j.salary_max, j.salary_currency
FROM 
	job_applications j
WHERE
	j.user_id = ? AND j.archived = ?
ORDER BY j.updated_at DESC
LIMIT ? OFFSET ?
`

type GetJobApplicationsByUserIDParams struct {
	UserID   int64
	Archived int64
	Limit    int64
	Offset   int64
}

type GetJobApplicationsByUserIDRow struct {
	AppliedAt      time.Time
	UpdatedAt      time.Time
	Company        string
	Title          string
	Status         string
	Url            string
	ID             int64
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
}

func (q *Queries) GetJobApplicationsByUserID(ctx context.Context, arg GetJobApplicationsByUserIDParams) ([]GetJobApplicationsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobApplicationsByUserID,
		arg.UserID,
		arg.Archived,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobApplicationsByUserIDRow
	for rows.Next() {
		var i GetJobApplicationsByUserIDRow
		if err := rows.Scan(
			&i.AppliedAt,
			&i.UpdatedAt,
			&i.Company,
			&i.Title,
			&i.Status,
			&i.Url,
			&i.ID,
			&i.SalaryMin,
			&i.SalaryMax,
			&i.SalaryCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobApplicationsByUserIDAndCompany = `-- name: GetJobApplicationsByUserIDAndCompany :many
SELECT
	j.applied_at, j.updated_at, j.company, j.title, j.status, j.url, j.id,
	j.salary_min, j.salary_max, j.salary_currency
FROM 
	job_applications j
WHERE
	j.company LIKE ? AND j.user_id = ? AND j.archived = ?
ORDER BY j.updated_at DESC
LIMIT ? OFFSET ?
`

type GetJobApplicationsByUserIDAndCompanyParams struct {
	Company  string
	UserID   int64
	Archived int64
	Limit    int64
	Offset   int64
}

type GetJobApplicationsByUserIDAndCompanyRow struct {
	AppliedAt      time.Time
	UpdatedAt      time.Time
	Company        string
	Title          string
	Status         string
	Url            string
	ID             int64
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
}

func (q *Queries) GetJobApplicationsByUserIDAndCompany(ctx context.Context, arg GetJobApplicationsByUserIDAndCompanyParams) ([]GetJobApplicationsByUserIDAndCompanyRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobApplicationsByUserIDAndCompany,
		arg.Company,
		arg.UserID,
		arg.Archived,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobApplicationsByUserIDAndCompanyRow
	for rows.Next() {
		var i GetJobApplicationsByUserIDAndCompanyRow
		if err := rows.Scan(
			&i.AppliedAt,
			&i.UpdatedAt,
			&i.Company,
			&i.Title,
			&i.Status,
			&i.Url,
			&i.ID,
			&i.SalaryMin,
			&i.SalaryMax,
			&i.SalaryCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobApplicationsByUserIDAndCompanyAndStatus = `-- name: GetJobApplicationsByUserIDAndCompanyAndStatus :many
SELECT
	j.applied_at, j.updated_at, j.company, j.title, j.status, j.url, j.id,
	j.salary_min, j.salary_max, j.salary_currency
FROM 
	job_applications j
WHERE
	j.company LIKE ? AND j.status = ? AND j.user_id = ? AND j.archived = ?
ORDER BY j.updated_at DESC
LIMIT ? OFFSET ?
`

type GetJobApplicationsByUserIDAndCompanyAndStatusParams struct {
	Company  string
	Status   string
	UserID   int64
	Archived int64
	Limit    int64
	Offset   int64
}

type GetJobApplicationsByUserIDAndCompanyAndStatusRow struct {
	AppliedAt      time.Time
	UpdatedAt      time.Time
	Company        string
	Title          string
	Status         string
	Url            string
	ID             int64
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
}

func (q *Queries) GetJobApplicationsByUserIDAndCompanyAndStatus(ctx context.Context, arg GetJobApplicationsByUserIDAndCompanyAndStatusParams) ([]GetJobApplicationsByUserIDAndCompanyAndStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobApplicationsByUserIDAndCompanyAndStatus,
		arg.Company,
		arg.Status,
		arg.UserID,
		arg.Archived,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobApplicationsByUserIDAndCompanyAndStatusRow
	for rows.Next() {
		var i GetJobApplicationsByUserIDAndCompanyAndStatusRow
		if err := rows.Scan(
			&i.AppliedAt,
			&i.UpdatedAt,
			&i.Company,
			&i.Title,
			&i.Status,
			&i.Url,
			&i.ID,
			&i.SalaryMin,
			&i.SalaryMax,
			&i.SalaryCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobApplicationsByUserIDAndStatus = `-- name: GetJobApplicationsByUserIDAndStatus :many
SELECT
	j.applied_at, j.updated_at, j.company, j.title, j.status, j.url, j.id,
	j.salary_min, j.salary_max, j.salary_currency
FROM 
	job_applications j
WHERE
	j.status = ? AND j.user_id = ? AND j.archived = ?
ORDER BY j.updated_at DESC
LIMIT ? OFFSET ?
`

type GetJobApplicationsByUserIDAndStatusParams struct {
	Status   string
	UserID   int64
	Archived int64
	Limit    int64
	Offset   int64
}

type GetJobApplicationsByUserIDAndStatusRow struct {
	AppliedAt      time.Time
	UpdatedAt      time.Time
	Company        string
	Title          string
	Status         string
	Url            string
	ID             int64
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
}

func (q *Queries) GetJobApplicationsByUserIDAndStatus(ctx context.Context, arg GetJobApplicationsByUserIDAndStatusParams) ([]GetJobApplicationsByUserIDAndStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobApplicationsByUserIDAndStatus,
		arg.Status,
		arg.UserID,
		arg.Archived,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobApplicationsByUserIDAndStatusRow
	for rows.Next() {
		var i GetJobApplicationsByUserIDAndStatusRow
		if err := rows.Scan(
			&i.AppliedAt,
			&i.UpdatedAt,
			&i.Company,
			&i.Title,
			&i.Status,
			&i.Url,
			&i.ID,
			&i.SalaryMin,
			&i.SalaryMax,
			&i.SalaryCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobApplicationsForStats = `-- name: GetJobApplicationsForStats :many
SELECT
	j.applied_at, j.status, MIN(h.created_at) AS heard_back_at
FROM 
	job_applications j
JOIN job_application_status_histories h 
	ON h.job_application_id = j.id
WHERE
	j.user_id = ? AND j.archived = 0
GROUP BY
	j.id
`

type GetJobApplicationsForStatsRow struct {
	AppliedAt   time.Time
	Status      string
	HeardBackAt interface{}
}

func (q *Queries) GetJobApplicationsForStats(ctx context.Context, userID int64) ([]GetJobApplicationsForStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobApplicationsForStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobApplicationsForStatsRow
	for rows.Next() {
		var i GetJobApplicationsForStatsRow
		if err := rows.Scan(&i.AppliedAt, &i.Status, &i.HeardBackAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertJobApplication = `-- name: InsertJobApplication :one
INSERT INTO job_applications (
    company, title, url, user_id,
    salary_min, salary_max, salary_currency
)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type InsertJobApplicationParams struct {
	Company        string
	Title          string
	Url            string
	UserID         int64
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
}

func (q *Queries) InsertJobApplication(ctx context.Context, arg InsertJobApplicationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertJobApplication,
		arg.Company,
		arg.Title,
		arg.Url,
		arg.UserID,
		arg.SalaryMin,
		arg.SalaryMax,
		arg.SalaryCurrency,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const unarchiveJobApplication = `-- name: UnarchiveJobApplication :exec
UPDATE job_applications
	SET archived = 0,
		updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
`

type UnarchiveJobApplicationParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) UnarchiveJobApplication(ctx context.Context, arg UnarchiveJobApplicationParams) error {
	_, err := q.db.ExecContext(ctx, unarchiveJobApplication, arg.ID, arg.UserID)
	return err
}

const updateJobApplication = `-- name: UpdateJobApplication :exec
UPDATE job_applications
SET company = ?,
    title = ?,
    status = ?,
    url = ?,
    salary_min = ?,
    salary_max = ?,
    salary_currency = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
`

type UpdateJobApplicationParams struct {
	Company        string
	Title          string
	Status         string
	Url            string
	SalaryMin      sql.NullInt64
	SalaryMax      sql.NullInt64
	SalaryCurrency sql.NullString
	ID             int64
	UserID         int64
}

func (q *Queries) UpdateJobApplication(ctx context.Context, arg UpdateJobApplicationParams) error {
	_, err := q.db.ExecContext(ctx, updateJobApplication,
		arg.Company,
		arg.Title,
		arg.Status,
		arg.Url,
		arg.SalaryMin,
		arg.SalaryMax,
		arg.SalaryCurrency,
		arg.ID,
		arg.UserID,
	)
	return err
}
